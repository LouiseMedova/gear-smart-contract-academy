"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPayloadTypeStructure = void 0;
const interfaces_1 = require("./interfaces");
const utils_1 = require("../utils");
const generate_1 = __importDefault(require("./generate"));
const regexp_1 = require("./regexp");
function getIfTuple(typeName, types, raw) {
    if (typeName.includes(':'))
        return null;
    const match = typeName.match(regexp_1.REGULAR_EXP.roundBracket);
    if (match) {
        const entryType = match[0].slice(1, match[0].length - 1);
        const splitted = (0, utils_1.splitByCommas)(entryType);
        const value = splitted.map((value) => createPayloadTypeStructure(value, types, raw));
        return raw ? value : generate_1.default.Tuple(typeName, value);
    }
    return null;
}
function getIfArray(typeName, types, raw) {
    const match = typeName.match(regexp_1.REGULAR_EXP.squareBracket);
    if (match) {
        const splitted = typeName.slice(1, typeName.length - 1).split(';');
        const value = [createPayloadTypeStructure(splitted[0], types, raw), parseInt(splitted[1])];
        return raw ? value : generate_1.default.Array(typeName, ...value);
    }
    return null;
}
function getIfGeneric(typeName, types, raw) {
    if (typeName.includes(':'))
        return null;
    const match = typeName.match(regexp_1.REGULAR_EXP.angleBracket);
    if (match) {
        const type = typeName.slice(0, match.index);
        if (type in interfaces_1.enumTypes) {
            const entryType = match[0].slice(1, match[0].length - 1);
            const splitted = (0, utils_1.splitByCommas)(entryType);
            const value = [
                createPayloadTypeStructure(splitted[0], types, raw),
                createPayloadTypeStructure(splitted[1], types, raw),
            ];
            if (raw) {
                if (type === 'Result') {
                    return {
                        _Result: {
                            ok: value[0],
                            err: value[1],
                        },
                    };
                }
                else {
                    return { [`_${type}`]: value[1] ? value : value[0] };
                }
            }
            return generate_1.default[type](typeName, ...value);
        }
        else {
            return createPayloadTypeStructure(type, types, raw);
        }
    }
    return null;
}
function getIfStruct(typeName, types, raw) {
    const value = {};
    if (types[typeName] && (0, utils_1.isJSON)(types[typeName])) {
        const jsoned = (0, utils_1.toJSON)(types[typeName]);
        Object.keys(jsoned).forEach((field) => {
            value[field] = createPayloadTypeStructure(jsoned[field], types, raw);
        });
    }
    else if ((0, utils_1.isJSON)(typeName)) {
        const jsonedTypeName = (0, utils_1.toJSON)(typeName);
        Object.keys(jsonedTypeName).forEach((field) => {
            value[field] = createPayloadTypeStructure(jsonedTypeName[field], types, raw);
        });
    }
    else {
        return null;
    }
    return raw ? value : generate_1.default.Struct(typeName, value);
}
function getIfEnum(typeName, types, raw) {
    if (types[typeName] && typeof types[typeName] === 'object') {
        if (Object.keys(types[typeName]).length === 1 && Object.keys(types[typeName]).includes('_enum')) {
            const type = types[typeName];
            const value = {};
            Object.keys(type['_enum']).forEach((field) => {
                value[field] = createPayloadTypeStructure(type['_enum'][field], types, raw);
            });
            return raw ? { _enum: value } : generate_1.default.Enum(typeName, value);
        }
    }
    return null;
}
/**
 *
 * @param typeName to create its structure
 * @param types
 * @param raw set it to true if there is a need to get type structure without additional fields
 * @returns
 */
function createPayloadTypeStructure(typeName, types, raw = false) {
    if (!typeName) {
        return undefined;
    }
    if (typeof typeName !== 'string') {
        typeName = JSON.stringify(typeName);
    }
    const regexp = new RegExp(`\\b${typeName}\\b`, 'gi');
    if (!types[typeName]) {
        const typeIgnoreCase = Object.keys(types).find((value) => regexp.test(value));
        if (typeIgnoreCase) {
            typeName = typeName.replace(regexp, typeIgnoreCase);
        }
    }
    const tuple = getIfTuple(typeName, types, raw);
    if (tuple) {
        return tuple;
    }
    const array = getIfArray(typeName, types, raw);
    if (array) {
        return array;
    }
    const generic = getIfGeneric(typeName, types, raw);
    if (generic) {
        return generic;
    }
    const _enum = getIfEnum(typeName, types, raw);
    if (_enum) {
        return _enum;
    }
    const struct = getIfStruct(typeName, types, raw);
    if (struct) {
        return struct;
    }
    return raw ? typeName : generate_1.default.Primitive(typeName);
}
exports.createPayloadTypeStructure = createPayloadTypeStructure;
