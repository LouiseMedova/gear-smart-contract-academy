"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypesFromTypeDef = exports.replaceNamespaces = exports.setNamespaces = exports.checkTypeAndPayload = exports.typeIsString = void 0;
const metadata_1 = require("@polkadot/types/metadata");
const util_1 = require("@polkadot/util");
const types_1 = require("@polkadot/types");
const string_1 = require("../utils/string");
const errors_1 = require("../errors");
const regexp_1 = require("./regexp");
function typeIsString(type) {
    return ['string', 'utf8', 'utf-8', 'text'].includes(type.toLowerCase());
}
exports.typeIsString = typeIsString;
function checkTypeAndPayload(type, payload) {
    if (payload === undefined) {
        throw new errors_1.CreateTypeError('Payload is not specified');
    }
    return type || 'Bytes';
}
exports.checkTypeAndPayload = checkTypeAndPayload;
function findTypeInNamepaces(type, namespaces) {
    for (let [key, value] of namespaces) {
        if (key.toLowerCase() === type.toLowerCase()) {
            return value;
        }
    }
    return undefined;
}
function setNamespaces(type, namespaces) {
    const matches = type.match(regexp_1.REGULAR_EXP.endWord);
    findTypeInNamepaces(type, namespaces);
    matches.forEach((match, index) => {
        if (namespaces) {
            let foundType = findTypeInNamepaces(match, namespaces) || findTypeInNamepaces(`${match}${matches[index + 1]}`, namespaces);
            if (foundType !== undefined) {
                type = type.replace(new RegExp(match, 'g'), foundType);
            }
        }
    });
    return type;
}
exports.setNamespaces = setNamespaces;
function replaceNamespaces(type, namespaces) {
    const match = type.match(regexp_1.REGULAR_EXP.endWord);
    namespaces.forEach((value, key) => {
        type = match.includes(value) ? type.replace(new RegExp(value, 'g'), key) : type;
    });
    return type;
}
exports.replaceNamespaces = replaceNamespaces;
function getTypesFromTypeDef(types, registry) {
    if (!registry) {
        registry = new types_1.TypeRegistry();
    }
    const typesFromTypeDef = {};
    const namespaces = new Map();
    const portableReg = new metadata_1.PortableRegistry(registry, (0, util_1.isHex)(types) ? (0, util_1.hexToU8a)(types) : types, true);
    portableReg.types.forEach(({ id, type: { path } }) => {
        const typeDef = portableReg.getTypeDef(id);
        if (path.length === 0 || (!typeDef.lookupName && !typeDef.lookupNameRoot)) {
            return;
        }
        const name = portableReg.getName(id);
        let camelCasedNamespace = (0, string_1.toCamelCase)(path.slice(0, path.length - 1));
        if (camelCasedNamespace === name) {
            camelCasedNamespace = path.length > 2 ? (0, string_1.toCamelCase)(path.slice(0, path.length - 2)) : undefined;
        }
        namespaces.set(name.replace(camelCasedNamespace, ''), name);
        typesFromTypeDef[typeDef.lookupName || typeDef.lookupNameRoot] = typeDef.type.toString();
    });
    return { typesFromTypeDef, namespaces };
}
exports.getTypesFromTypeDef = getTypesFromTypeDef;
