"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GearStorage = void 0;
const util_1 = require("@polkadot/util");
const create_type_1 = require("./create-type");
const PREFIXES = {
    prog: Buffer.from('g::prog::').toString('hex'),
    pages: Buffer.from('g::pages::').toString('hex'),
};
const SEPARATOR = Buffer.from('::').toString('hex');
class GearStorage {
    constructor(api) {
        this.api = api;
        this.createType = new create_type_1.CreateType(api);
    }
    /**
     * Get program from chain
     * @param programId
     * @returns
     */
    gProg(programId) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = (yield this.api.rpc.state.getStorage(`0x${PREFIXES.prog}${programId.slice(2)}`));
            const program = this.api.createType('Program', storage.unwrap());
            return program.isActive ? program.asActive : program.asTerminated;
        });
    }
    /**
     * Get list of pages for program
     * @param programId
     * @param pagesList - list with pages numbers
     * @returns
     */
    gPages(programId, gProg) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = {};
            gProg.persistent_pages.forEach((value) => {
                keys[value.toNumber()] = `0x${PREFIXES.pages}${programId.slice(2)}${SEPARATOR}${this.api
                    .createType('Bytes', Array.from(this.api.createType('u32', value).toU8a()))
                    .toHex()
                    .slice(2)}`;
            });
            const pages = {};
            for (let key of Object.keys(keys)) {
                const storage = (yield this.api.rpc.state.getStorage(keys[key])).unwrap().toU8a();
                pages[key] = storage;
            }
            return pages;
        });
    }
    /**
     * Get codeHash of program on-chain
     * @param programId
     * @returns codeHash in hex format
     */
    getCodeHash(programId) {
        return __awaiter(this, void 0, void 0, function* () {
            const program = yield this.gProg(programId);
            return (0, util_1.u8aToHex)(program.code_hash);
        });
    }
}
exports.GearStorage = GearStorage;
