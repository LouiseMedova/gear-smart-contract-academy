"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GearBalance = void 0;
const Keyring_1 = require("./Keyring");
const errors_1 = require("./errors");
class GearBalance {
    constructor(gearApi) {
        this.api = gearApi;
    }
    findOut(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: balance } = (yield this.api.query.system.account(publicKey));
            return this.api.createType('Balance', balance.free);
        });
    }
    transferFromAlice(to, value, eventsCallback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const unsub = yield this.api.tx.balances
                    .transfer(to, value)
                    .signAndSend(yield Keyring_1.GearKeyring.fromSuri('//Alice', 'Alice default'), ({ events }) => {
                    events.forEach(({ event: { data, method } }) => {
                        if (eventsCallback) {
                            eventsCallback(method, data);
                        }
                        if (method === 'Transfer') {
                            unsub();
                            resolve(0);
                        }
                    });
                });
            }
            catch (error) {
                reject(new errors_1.TransactionError(error.message));
            }
        }));
    }
    transferBalance(keyring, to, value, eventsCallback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const unsub = yield this.api.tx.balances.transfer(to, value).signAndSend(keyring, ({ events, status }) => {
                    events.forEach(({ event: { data, method } }) => {
                        if (eventsCallback) {
                            eventsCallback(method, data);
                        }
                        if (method === 'Transfer') {
                            unsub();
                            resolve(0);
                        }
                    });
                });
            }
            catch (error) {
                reject(new errors_1.TransactionError(error.message));
            }
        }));
    }
}
exports.GearBalance = GearBalance;
