"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GearKeyring = void 0;
const api_1 = require("@polkadot/api");
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const wasm_crypto_1 = require("@polkadot/wasm-crypto");
class GearKeyring {
    static unlock(keyring, passphrase) {
        if (keyring.isLocked) {
            keyring.unlock(passphrase);
        }
        return keyring;
    }
    static fromSuri(suri, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = new api_1.Keyring({ type: 'sr25519' });
            yield (0, wasm_crypto_1.waitReady)();
            const keyPair = keyring.addFromUri(suri, { name });
            return keyPair;
        });
    }
    static fromKeyPair(pair, name) {
        const keyring = new api_1.Keyring({ type: 'sr25519' });
        return GearKeyring.unlock(keyring.addFromPair(pair, { name }));
    }
    static fromJson(keypairJson, passphrase) {
        const json = (0, util_1.isString)(keypairJson) ? JSON.parse(keypairJson) : keypairJson;
        const keyring = new api_1.Keyring().addFromJson(json);
        return GearKeyring.unlock(keyring, passphrase);
    }
    static fromSeed(seed, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = new api_1.Keyring({ type: 'sr25519' });
            yield (0, wasm_crypto_1.waitReady)();
            const keypair = (0, util_1.isU8a)(seed) ? keyring.addFromSeed(seed, { name }) : keyring.addFromSeed((0, util_1.hexToU8a)(seed), { name });
            return keypair;
        });
    }
    static fromMnemonic(mnemonic, name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield GearKeyring.fromSuri(mnemonic, name);
        });
    }
    static toJson(keyring, passphrase) {
        return keyring.toJson(passphrase);
    }
    static create(name, passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            const mnemonic = (0, util_crypto_1.mnemonicGenerate)();
            const seed = (0, util_crypto_1.mnemonicToMiniSecret)(mnemonic);
            const keyring = yield GearKeyring.fromSeed(seed, name);
            return {
                keyring,
                mnemonic: mnemonic,
                seed: (0, util_1.u8aToHex)(seed),
                json: keyring.toJson(passphrase),
            };
        });
    }
    static generateMnemonic() {
        return (0, util_crypto_1.mnemonicGenerate)();
    }
    static generateSeed(mnemonic) {
        if (!mnemonic) {
            mnemonic = (0, util_crypto_1.mnemonicGenerate)();
        }
        return { seed: (0, util_1.u8aToHex)((0, util_crypto_1.mnemonicToMiniSecret)(mnemonic)), mnemonic };
    }
    static checkSign(publicKey, signature, message) {
        if ((0, util_crypto_1.signatureVerify)(message, signature, publicKey).isValid) {
            return true;
        }
        else {
            return false;
        }
    }
    static sign(keyring, message) {
        return keyring.sign((0, util_1.stringToU8a)(message));
    }
    static decodeAddress(publicKey) {
        return (0, util_1.u8aToHex)(new api_1.Keyring().decodeAddress(publicKey));
    }
    static encodeAddress(publicKeyRaw) {
        return new api_1.Keyring().encodeAddress(publicKeyRaw);
    }
    static checkPublicKey(publicKey) {
        try {
            GearKeyring.decodeAddress(publicKey);
        }
        catch (error) {
            return false;
        }
        return true;
    }
}
exports.GearKeyring = GearKeyring;
