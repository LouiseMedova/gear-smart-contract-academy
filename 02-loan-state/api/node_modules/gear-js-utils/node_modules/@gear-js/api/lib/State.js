"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GearProgramState = void 0;
const wasm_1 = require("./wasm");
const state_errors_1 = require("./errors/state.errors");
const Storage_1 = require("./Storage");
class GearProgramState extends Storage_1.GearStorage {
    /**
     * Decode state to meta_state_output type
     * @param state - Uint8Array state representation
     * @param meta - Metadata
     * @returns decoded state
     */
    decodeState(state, meta) {
        if (!state) {
            throw new state_errors_1.ReadStateError(`Unable to read state. meta_state function is not specified in metadata`);
        }
        const bytes = this.api.createType('Bytes', Array.from(state));
        const decoded = this.createType.create(meta.meta_state_output, bytes, meta);
        return decoded;
    }
    /**
     * Encode input parameters to read meta state
     * @param meta - Metadata
     * @param inputValue - input parameters
     * @returns ArrayBuffer with encoded data
     */
    encodeInput(meta, inputValue) {
        const encoded = this.createType.create(meta.meta_state_input, inputValue, meta);
        return encoded.toU8a();
    }
    /**
     * Read state of particular program
     * @param programId
     * @param metaWasm - file with metadata
     * @returns decoded state
     */
    read(programId, metaWasm, inputValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const program = yield this.gProg(programId);
            if (!program) {
                throw new state_errors_1.ReadStateError('Program is terminated');
            }
            const pages = yield this.gPages(programId, program);
            const block = yield this.api.blocks.getFinalizedHead();
            const blockTimestamp = yield this.api.blocks.getBlockTimestamp(block.toHex());
            if (!pages) {
                throw new state_errors_1.ReadStateError(`Unable to read state. Unable to recieve program pages from chain`);
            }
            const metadata = yield (0, wasm_1.getWasmMetadata)(metaWasm);
            if (!metadata.meta_state_output) {
                throw new state_errors_1.ReadStateError(`Unable to read state. meta_state_output type is not specified in metadata`);
            }
            if (metadata.meta_state_input && inputValue === undefined) {
                throw new state_errors_1.ReadStateError(`Unable to read state. inputValue not specified`);
            }
            const encodedInput = inputValue === undefined ? undefined : this.encodeInput(metadata, inputValue);
            const state = yield (0, wasm_1.readState)(metaWasm, pages, encodedInput, blockTimestamp);
            return this.decodeState(state, metadata);
        });
    }
}
exports.GearProgramState = GearProgramState;
