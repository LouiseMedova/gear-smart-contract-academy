import '@polkadot/api-augment';
import { blake2AsHex, blake2AsU8a, randomAsHex, mnemonicGenerate, mnemonicToMiniSecret, signatureVerify } from '@polkadot/util-crypto';
import { stringCamelCase, isHex, hexToU8a, isU8a, u8aToHex, isFunction, isString, stringToU8a, u8aToString } from '@polkadot/util';
import { TypeRegistry, Bytes, GenericEventData, Type, GenericEvent } from '@polkadot/types';
import { PortableRegistry } from '@polkadot/types/metadata';
import { Keyring, ApiPromise, WsProvider } from '@polkadot/api';
import { waitReady } from '@polkadot/wasm-crypto';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class GearError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'GearError';
    }
}
class CreateTypeError extends GearError {
    constructor(message) {
        super();
        this.name = 'CreateTypeError';
        this.message = `Can't create type.`;
        this.message = `${this.message} ${message}`;
    }
}
class TransactionError extends GearError {
    constructor(message) {
        super();
        this.name = 'TransactionError';
        this.message = `${message}`;
    }
}

class SendMessageError extends GearError {
    constructor(message) {
        super(message || `Can't send message. Params are invalid`);
        this.name = 'SendMessageError';
    }
}
class SendReplyError extends GearError {
    constructor(message) {
        super(message || `Can't send reply. Params are invalid`);
        this.name = 'SendReplyError';
    }
}

class SubmitProgramError extends GearError {
    constructor(message) {
        super(message || `Unable to submit the program. Params are invalid`);
        this.name = 'SubmitProgramError';
    }
}
class GetGasSpentError extends GearError {
    constructor(message) {
        super(`Unable to get gasSpent. ${message}` || `Unable to get gasSpent. Params are invalid`);
        this.name = 'GetGasSpentError';
    }
}

var enumTypes;
(function (enumTypes) {
    enumTypes[enumTypes["Primitive"] = 0] = "Primitive";
    enumTypes[enumTypes["Tuple"] = 1] = "Tuple";
    enumTypes[enumTypes["Struct"] = 2] = "Struct";
    enumTypes[enumTypes["Enum"] = 3] = "Enum";
    enumTypes[enumTypes["Array"] = 4] = "Array";
    enumTypes[enumTypes["Option"] = 5] = "Option";
    enumTypes[enumTypes["Result"] = 6] = "Result";
    enumTypes[enumTypes["Vec"] = 7] = "Vec";
    enumTypes[enumTypes["BTreeMap"] = 8] = "BTreeMap";
    enumTypes[enumTypes["BTreeSet"] = 9] = "BTreeSet";
})(enumTypes || (enumTypes = {}));

function toCamelCase(array) {
    let result = stringCamelCase(array.join('_'));
    result = result.slice(0, 1).toUpperCase() + result.slice(1, result.length);
    return result;
}
function splitByCommas(str) {
    let counter = 0;
    let result = [];
    let lastTypeIndex = 0;
    try {
        Array.from(str).forEach((char, index) => {
            if (char === ',' && counter === 0) {
                result.push(str.slice(lastTypeIndex, index).trim());
                lastTypeIndex = index + 1;
            }
            (char === '<' || char === '(') && counter++;
            (char === '>' || char === ')') && counter--;
        });
        result.push(str.slice(lastTypeIndex).trim());
    }
    catch (_) { }
    return result;
}

function isJSON(data) {
    try {
        JSON.parse(data);
    }
    catch (error) {
        try {
            if (JSON.stringify(data)[0] !== '{') {
                return false;
            }
        }
        catch (error) {
            return false;
        }
        return true;
    }
    return true;
}
function toJSON(data) {
    try {
        return JSON.parse(data);
    }
    catch (error) {
        return data;
    }
}

const REGULAR_EXP$1 = {
    endWord: /\b\w+\b/g,
    angleBracket: /<.+>/,
    roundBracket: /^\(.+\)$/,
    squareBracket: /^\[.+\]$/,
};

function typeIsString(type) {
    return ['string', 'utf8', 'utf-8', 'text'].includes(type.toLowerCase());
}
function checkTypeAndPayload(type, payload) {
    if (payload === undefined) {
        throw new CreateTypeError('Payload is not specified');
    }
    return type || 'Bytes';
}
function findTypeInNamepaces(type, namespaces) {
    for (let [key, value] of namespaces) {
        if (key.toLowerCase() === type.toLowerCase()) {
            return value;
        }
    }
    return undefined;
}
function setNamespaces(type, namespaces) {
    const matches = type.match(REGULAR_EXP$1.endWord);
    findTypeInNamepaces(type, namespaces);
    matches.forEach((match, index) => {
        if (namespaces) {
            let foundType = findTypeInNamepaces(match, namespaces) || findTypeInNamepaces(`${match}${matches[index + 1]}`, namespaces);
            if (foundType !== undefined) {
                type = type.replace(new RegExp(match, 'g'), foundType);
            }
        }
    });
    return type;
}
function replaceNamespaces(type, namespaces) {
    const match = type.match(REGULAR_EXP$1.endWord);
    namespaces.forEach((value, key) => {
        type = match.includes(value) ? type.replace(new RegExp(value, 'g'), key) : type;
    });
    return type;
}
function getTypesFromTypeDef(types, registry) {
    if (!registry) {
        registry = new TypeRegistry();
    }
    const typesFromTypeDef = {};
    const namespaces = new Map();
    const portableReg = new PortableRegistry(registry, isHex(types) ? hexToU8a(types) : types, true);
    portableReg.types.forEach(({ id, type: { path } }) => {
        const typeDef = portableReg.getTypeDef(id);
        if (path.length === 0 || (!typeDef.lookupName && !typeDef.lookupNameRoot)) {
            return;
        }
        const name = portableReg.getName(id);
        let camelCasedNamespace = toCamelCase(path.slice(0, path.length - 1));
        if (camelCasedNamespace === name) {
            camelCasedNamespace = path.length > 2 ? toCamelCase(path.slice(0, path.length - 2)) : undefined;
        }
        namespaces.set(name.replace(camelCasedNamespace, ''), name);
        typesFromTypeDef[typeDef.lookupName || typeDef.lookupNameRoot] = typeDef.type.toString();
    });
    return { typesFromTypeDef, namespaces };
}

class CreateType {
    constructor(gearApi) {
        this.registry = (gearApi === null || gearApi === void 0 ? void 0 : gearApi.registry) || new TypeRegistry();
        this.namespaces = undefined;
    }
    createRegistry(types) {
        if (!types) {
            return null;
        }
        if (isHex(types) || isU8a(types)) {
            const { typesFromTypeDef, namespaces } = getTypesFromTypeDef(types, this.registry);
            types = typesFromTypeDef;
            this.namespaces = namespaces;
        }
        this.registerTypes(types);
        return this.namespaces;
    }
    /**
     * Register custom types in case of use custom types without
     * @param types
     * @example
     * ```javascript
     * const types = {
     *    CustomStruct: {
     *      fieldA: 'String',
     *      fieldB: 'u8'
     *    },
     *    CustomEnum: {
     *      _enum: {
     *        optionA: 'Option<CustomStruct>',
     *        optionB: 'BTreeSet<i32>'
     *      }
     *    }
     * };
     * const createType = new CreateType();
     * createType.registerTypes(types);
     * createType.create('CustomStruct', { fieldA: 'Hello', fieldB: 255 });
     * ```
     */
    registerTypes(types) {
        this.registry.setKnownTypes({ types: Object.assign({}, types) });
        this.registry.register(Object.assign({}, types));
    }
    /**
     *
     * @param type `TypeName` to encode or decode payload
     * @param payload `Payload` that have to be encoded or decoded
     * @param meta `Metadata` if type isn't standart rust Type
     * @returns Codec
     * @example
     * ```javascript
     * const createType = new CreateType();
     * const encoded = createType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     *
     * const decoded = createType.create('String', '0x48656c6c6f2c20576f726c6421');
     * console.log(decoded.toHuman()); // "Hello, World!"
     *
     * // create type with metadata
     * const metadata = fs.readFileSync('path/to/file/with/metadata/*.meta.wasm);
     * const encoded = create(metadata.handle_input, somePayload, metadata);
     * console.log(encoded.toHex());
     * ```
     */
    create(type, payload, meta) {
        type = checkTypeAndPayload(type, payload);
        const namespaces = (meta === null || meta === void 0 ? void 0 : meta.types) ? this.createRegistry(meta.types) : this.createRegistry();
        return this.createType(namespaces ? setNamespaces(type, namespaces) : type, isJSON(payload) ? toJSON(payload) : payload);
    }
    /**
     *
     * @param type `TypeName` to encode or decode payload
     * @param payload `Payload` that have to be encoded or decoded
     * @param meta `Metadata` if type isn't standart rust Type
     * @returns Codec
     * @example
     * ```javascript
     * const encoded = CreateType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     * ```
     */
    static create(type, payload, meta) {
        const createType = new CreateType();
        return createType.create(type, payload, meta);
    }
    createType(type, data) {
        if (typeIsString(type)) {
            return this.registry.createType('String', data);
        }
        else if (type.toLowerCase() === 'bytes') {
            if (data instanceof Uint8Array) {
                return this.registry.createType('Bytes', Array.from(data));
            }
            else if (data instanceof Bytes) {
                return data;
            }
            return this.registry.createType('Bytes', data);
        }
        else {
            return this.registry.createType(type, data);
        }
    }
    /**
     * @deprecated use `CreateType.create()`
     */
    static encode(type, payload, meta) {
        const createType = new CreateType();
        return createType.create(type, payload, meta);
    }
    /**
     * @deprecated use `CreateType.create()`
     */
    static decode(type, payload, meta) {
        const createType = new CreateType();
        return createType.create(type, payload, meta);
    }
}

function createPayload(createType, type, data, meta) {
    if (data === undefined) {
        return '0x00';
    }
    if (isHex(data)) {
        return data;
    }
    else if (isU8a(data)) {
        return u8aToHex(data);
    }
    let payload = data;
    if (meta && type) {
        const encoded = createType.create(type, data, meta);
        payload = isHex(encoded) ? encoded : encoded.toHex();
    }
    else if (type) {
        try {
            const encoded = createType.create(type, data);
            payload = isHex(encoded) ? encoded : encoded.toHex();
        }
        catch (error) {
            console.error(error.message);
        }
    }
    return payload;
}
function generateCodeHash(code) {
    return blake2AsHex(code, 256);
}
function generateProgramId(code, salt) {
    const codeHashU8a = blake2AsU8a(code, 256);
    const saltU8a = CreateType.create('Vec<u8>', salt).toU8a().slice(1);
    const id = new Uint8Array(codeHashU8a.byteLength + saltU8a.byteLength);
    id.set(codeHashU8a);
    id.set(saltU8a, codeHashU8a.byteLength);
    return blake2AsHex(id, 256);
}

function transformTypes(types) {
    return Object.values(types).reduce((res, types) => (Object.assign(Object.assign({}, res), types)), {});
}

const getTree = (type, name, value, count) => {
    const tree = { type, name, value: isJSON(value) ? toJSON(value) : value };
    return type === 'Array' ? Object.assign(Object.assign({}, tree), { count }) : tree;
};
var generate = {
    Primitive: (type) => {
        return getTree('Primitive', type, type);
    },
    Tuple: (name, type) => {
        return getTree('Tuple', name, type);
    },
    Struct: (name, value) => {
        return getTree('Struct', name, value);
    },
    Enum: (name, options) => {
        return getTree('Enum', name, options);
    },
    Array: (name, type, count) => {
        return getTree('Array', name, type, count);
    },
    Option: (name, some) => {
        return getTree('Option', name, some);
    },
    Result: (name, ok, err) => {
        return getTree('Result', name, { ok, err });
    },
    Vec: (name, type) => {
        return getTree('Vec', name, type);
    },
    BTreeMap: (name, key, value) => {
        return getTree('BTreeMap', name, { key, value });
    },
    BTreeSet: (name, type) => {
        return getTree('BTreeSet', name, type);
    },
};

function getIfTuple(typeName, types, raw) {
    if (typeName.includes(':'))
        return null;
    const match = typeName.match(REGULAR_EXP$1.roundBracket);
    if (match) {
        const entryType = match[0].slice(1, match[0].length - 1);
        const splitted = splitByCommas(entryType);
        const value = splitted.map((value) => createPayloadTypeStructure(value, types, raw));
        return raw ? value : generate.Tuple(typeName, value);
    }
    return null;
}
function getIfArray(typeName, types, raw) {
    const match = typeName.match(REGULAR_EXP$1.squareBracket);
    if (match) {
        const splitted = typeName.slice(1, typeName.length - 1).split(';');
        const value = [createPayloadTypeStructure(splitted[0], types, raw), parseInt(splitted[1])];
        return raw ? value : generate.Array(typeName, ...value);
    }
    return null;
}
function getIfGeneric(typeName, types, raw) {
    if (typeName.includes(':'))
        return null;
    const match = typeName.match(REGULAR_EXP$1.angleBracket);
    if (match) {
        const type = typeName.slice(0, match.index);
        if (type in enumTypes) {
            const entryType = match[0].slice(1, match[0].length - 1);
            const splitted = splitByCommas(entryType);
            const value = [
                createPayloadTypeStructure(splitted[0], types, raw),
                createPayloadTypeStructure(splitted[1], types, raw),
            ];
            if (raw) {
                if (type === 'Result') {
                    return {
                        _Result: {
                            ok: value[0],
                            err: value[1],
                        },
                    };
                }
                else {
                    return { [`_${type}`]: value[1] ? value : value[0] };
                }
            }
            return generate[type](typeName, ...value);
        }
        else {
            return createPayloadTypeStructure(type, types, raw);
        }
    }
    return null;
}
function getIfStruct(typeName, types, raw) {
    const value = {};
    if (types[typeName] && isJSON(types[typeName])) {
        const jsoned = toJSON(types[typeName]);
        Object.keys(jsoned).forEach((field) => {
            value[field] = createPayloadTypeStructure(jsoned[field], types, raw);
        });
    }
    else if (isJSON(typeName)) {
        const jsonedTypeName = toJSON(typeName);
        Object.keys(jsonedTypeName).forEach((field) => {
            value[field] = createPayloadTypeStructure(jsonedTypeName[field], types, raw);
        });
    }
    else {
        return null;
    }
    return raw ? value : generate.Struct(typeName, value);
}
function getIfEnum(typeName, types, raw) {
    if (types[typeName] && typeof types[typeName] === 'object') {
        if (Object.keys(types[typeName]).length === 1 && Object.keys(types[typeName]).includes('_enum')) {
            const type = types[typeName];
            const value = {};
            Object.keys(type['_enum']).forEach((field) => {
                value[field] = createPayloadTypeStructure(type['_enum'][field], types, raw);
            });
            return raw ? { _enum: value } : generate.Enum(typeName, value);
        }
    }
    return null;
}
/**
 *
 * @param typeName to create its structure
 * @param types
 * @param raw set it to true if there is a need to get type structure without additional fields
 * @returns
 */
function createPayloadTypeStructure(typeName, types, raw = false) {
    if (!typeName) {
        return undefined;
    }
    if (typeof typeName !== 'string') {
        typeName = JSON.stringify(typeName);
    }
    const regexp = new RegExp(`\\b${typeName}\\b`, 'gi');
    if (!types[typeName]) {
        const typeIgnoreCase = Object.keys(types).find((value) => regexp.test(value));
        if (typeIgnoreCase) {
            typeName = typeName.replace(regexp, typeIgnoreCase);
        }
    }
    const tuple = getIfTuple(typeName, types, raw);
    if (tuple) {
        return tuple;
    }
    const array = getIfArray(typeName, types, raw);
    if (array) {
        return array;
    }
    const generic = getIfGeneric(typeName, types, raw);
    if (generic) {
        return generic;
    }
    const _enum = getIfEnum(typeName, types, raw);
    if (_enum) {
        return _enum;
    }
    const struct = getIfStruct(typeName, types, raw);
    if (struct) {
        return struct;
    }
    return raw ? typeName : generate.Primitive(typeName);
}

function decodeHexTypes(hexTypes) {
    let { typesFromTypeDef, namespaces } = getTypesFromTypeDef(hexToU8a(hexTypes));
    const result = {};
    namespaces.forEach((value, key) => {
        const replaced = replaceNamespaces(typesFromTypeDef[value], namespaces);
        result[key] = isJSON(replaced) ? JSON.parse(replaced) : replaced;
    });
    return result;
}

class GearTransaction {
    constructor(gearApi) {
        this.api = gearApi;
        this.createType = new CreateType(gearApi);
    }
    signAndSend(account, optionsOrCallback, optionalCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const [options, callback] = isFunction(optionsOrCallback)
                ? [undefined, optionsOrCallback]
                : [optionsOrCallback, optionalCallback];
            try {
                return yield this.submitted.signAndSend(account, options, callback);
            }
            catch (error) {
                const errorCode = +error.message.split(':')[0];
                if (errorCode === 1010) {
                    throw new TransactionError('Account balance too low');
                }
                else {
                    throw new TransactionError(error.message);
                }
            }
        });
    }
}

class GearGasSpent {
    constructor(api) {
        this.api = api;
        this.createType = new CreateType(this.api);
    }
    getPayload(payload, metaOrTypeOfPayload, meta_type) {
        if (isHex(payload)) {
            return payload;
        }
        else if (isU8a(payload)) {
            return u8aToHex(payload);
        }
        if (!metaOrTypeOfPayload) {
            throw new GetGasSpentError('Impossible to create bytes from payload without specified type or meta');
        }
        const [type, meta] = isString(metaOrTypeOfPayload)
            ? [metaOrTypeOfPayload, undefined]
            : [metaOrTypeOfPayload[meta_type], metaOrTypeOfPayload];
        return createPayload(this.createType, type, payload, meta);
    }
    init(sourceId, code, payload, value, metaOrTypeOfPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.rpc['gear'].getInitGasSpent(sourceId, isHex(code) ? code : this.createType.create('bytes', Array.from(code)).toHex(), this.getPayload(payload, metaOrTypeOfPayload, 'init_input'), value || 0);
        });
    }
    handle(sourceId, destinationId, payload, value, metaOrTypeOfPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.rpc['gear'].getHandleGasSpent(sourceId, destinationId, this.getPayload(payload, metaOrTypeOfPayload, 'handle_input'), value || 0);
        });
    }
    reply(sourceId, messageId, exitCode, payload, value, metaOrTypeOfPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.rpc['gear'].getReplyGasSpent(sourceId, messageId, exitCode, this.getPayload(payload, metaOrTypeOfPayload, 'async_handle_input'), value || 0);
        });
    }
}

class GearProgram extends GearTransaction {
    constructor(gearApi) {
        super(gearApi);
        this.gasSpent = new GearGasSpent(gearApi);
    }
    /**
     * @param program Upload program data
     * @param meta Metadata
     * @returns ProgramId
     * @example
     * ```javascript
     * const code = fs.readFileSync('path/to/program.opt.wasm');
     * const meta = await getWasmMetadata(fs.readFileSync('path/to/program.meta.wasm'));
     * const api = await GearApi.create();
     * const { programId, salt, submitted } = api.program.submit({
     *   code,
     *   initPayload: {field: 'someValue'},
     *   gasLimit: 20_000_000,
     * }, meta)
     * api.program.signAndSend(account, (events) => {
     *   events.forEach(({event}) => console.log(event.toHuman()))
     * })
     * ```
     */
    submit(program, meta, messageType) {
        const salt = program.salt || randomAsHex(20);
        const code = this.createType.create('bytes', Array.from(program.code));
        let payload = createPayload(this.createType, messageType || (meta === null || meta === void 0 ? void 0 : meta.init_input), program.initPayload, meta);
        try {
            this.submitted = this.api.tx.gear.submitProgram(code, salt, payload, program.gasLimit, program.value || 0);
            const programId = generateProgramId(code, salt);
            return { programId, salt, submitted: this.submitted };
        }
        catch (error) {
            throw new SubmitProgramError();
        }
    }
    /**
     * Get ids of all uploaded programs
     * @returns
     */
    allUploadedPrograms() {
        return __awaiter(this, void 0, void 0, function* () {
            let programs = (yield this.api.rpc.state.getKeys('g::prog::')).map((prog) => {
                return `0x${prog.toHex().slice(Buffer.from('g::prog::').toString('hex').length + 2)}`;
            });
            return programs;
        });
    }
}

class GearMessage extends GearTransaction {
    /**
     * Send message
     * @param message Message parameters
     * @param meta Metadata
     * @param messageType MessageType
     * @returns Submitted result
     * ```javascript
     * const api = await GearApi.create()
     * const programId = '0xd7540ae9da85e33b47276e2cb4efc2f0b58fef1227834f21ddc8c7cb551cced6'
     * api.message.submit({
     *  destination: messageId,
     *  payload: 'Hello, World!',
     *  gasLimit: 20_000_000
     * }, undefiend, 'String')
     * api.message.signAndSend(account, (events) => {
     *  events.forEach(({event}) => console.log(event.toHuman()))
     * })
     * ```
     */
    submit(message, meta, messageType) {
        let payload = createPayload(this.createType, messageType || (meta === null || meta === void 0 ? void 0 : meta.handle_input), message.payload, meta);
        try {
            this.submitted = this.api.tx.gear.sendMessage(message.destination, payload, message.gasLimit, message.value || 0);
            return this.submitted;
        }
        catch (error) {
            throw new SendMessageError();
        }
    }
}

class GearKeyring {
    static unlock(keyring, passphrase) {
        if (keyring.isLocked) {
            keyring.unlock(passphrase);
        }
        return keyring;
    }
    static fromSuri(suri, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = new Keyring({ type: 'sr25519' });
            yield waitReady();
            const keyPair = keyring.addFromUri(suri, { name });
            return keyPair;
        });
    }
    static fromKeyPair(pair, name) {
        const keyring = new Keyring({ type: 'sr25519' });
        return GearKeyring.unlock(keyring.addFromPair(pair, { name }));
    }
    static fromJson(keypairJson, passphrase) {
        const json = isString(keypairJson) ? JSON.parse(keypairJson) : keypairJson;
        const keyring = new Keyring().addFromJson(json);
        return GearKeyring.unlock(keyring, passphrase);
    }
    static fromSeed(seed, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = new Keyring({ type: 'sr25519' });
            yield waitReady();
            const keypair = isU8a(seed) ? keyring.addFromSeed(seed, { name }) : keyring.addFromSeed(hexToU8a(seed), { name });
            return keypair;
        });
    }
    static fromMnemonic(mnemonic, name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield GearKeyring.fromSuri(mnemonic, name);
        });
    }
    static toJson(keyring, passphrase) {
        return keyring.toJson(passphrase);
    }
    static create(name, passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            const mnemonic = mnemonicGenerate();
            const seed = mnemonicToMiniSecret(mnemonic);
            const keyring = yield GearKeyring.fromSeed(seed, name);
            return {
                keyring,
                mnemonic: mnemonic,
                seed: u8aToHex(seed),
                json: keyring.toJson(passphrase),
            };
        });
    }
    static generateMnemonic() {
        return mnemonicGenerate();
    }
    static generateSeed(mnemonic) {
        if (!mnemonic) {
            mnemonic = mnemonicGenerate();
        }
        return { seed: u8aToHex(mnemonicToMiniSecret(mnemonic)), mnemonic };
    }
    static checkSign(publicKey, signature, message) {
        if (signatureVerify(message, signature, publicKey).isValid) {
            return true;
        }
        else {
            return false;
        }
    }
    static sign(keyring, message) {
        return keyring.sign(stringToU8a(message));
    }
    static decodeAddress(publicKey) {
        return u8aToHex(new Keyring().decodeAddress(publicKey));
    }
    static encodeAddress(publicKeyRaw) {
        return new Keyring().encodeAddress(publicKeyRaw);
    }
    static checkPublicKey(publicKey) {
        try {
            GearKeyring.decodeAddress(publicKey);
        }
        catch (error) {
            return false;
        }
        return true;
    }
}

class GearBalance {
    constructor(gearApi) {
        this.api = gearApi;
    }
    findOut(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: balance } = (yield this.api.query.system.account(publicKey));
            return this.api.createType('Balance', balance.free);
        });
    }
    transferFromAlice(to, value, eventsCallback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const unsub = yield this.api.tx.balances
                    .transfer(to, value)
                    .signAndSend(yield GearKeyring.fromSuri('//Alice', 'Alice default'), ({ events }) => {
                    events.forEach(({ event: { data, method } }) => {
                        if (eventsCallback) {
                            eventsCallback(method, data);
                        }
                        if (method === 'Transfer') {
                            unsub();
                            resolve(0);
                        }
                    });
                });
            }
            catch (error) {
                reject(new TransactionError(error.message));
            }
        }));
    }
    transferBalance(keyring, to, value, eventsCallback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const unsub = yield this.api.tx.balances.transfer(to, value).signAndSend(keyring, ({ events, status }) => {
                    events.forEach(({ event: { data, method } }) => {
                        if (eventsCallback) {
                            eventsCallback(method, data);
                        }
                        if (method === 'Transfer') {
                            unsub();
                            resolve(0);
                        }
                    });
                });
            }
            catch (error) {
                reject(new TransactionError(error.message));
            }
        }));
    }
}

class GearEventData extends GenericEventData {
    constructor(data) {
        super(data.registry, data.toU8a(), data.meta, data.section, data.method);
    }
}
class MessageInfoData extends GearEventData {
    get messageId() {
        return this[0]['messageId'];
    }
    get programId() {
        return this[0]['programId'];
    }
    get origin() {
        return this[0]['origin'];
    }
}
class ProgramData extends GearEventData {
    get info() {
        return this[0];
    }
    get reason() {
        if (this.length > 1) {
            return this[1];
        }
        return null;
    }
}
class LogData extends GearEventData {
    get id() {
        return this[0]['id'];
    }
    get source() {
        return this[0]['source'];
    }
    get destination() {
        return this[0]['destination'];
    }
    get payload() {
        return this[0]['payload'];
    }
    get value() {
        return this[0]['value'];
    }
    get reply() {
        return this[0]['reply'];
    }
}
class TransferData extends GearEventData {
    get from() {
        return this[0];
    }
    get to() {
        return this[1];
    }
    get value() {
        return this[2];
    }
}
class InitMessageEnqueuedData extends MessageInfoData {
}
class DispatchMessageEnqueuedData extends MessageInfoData {
}
class InitSuccessData extends MessageInfoData {
}
class InitFailureData extends ProgramData {
}
class DebugData extends GearEventData {
    get dispatchQueue() {
        return this[0]['dispatchQueue'];
    }
    get programs() {
        return this[0]['programs'];
    }
}
class ExecutionResult extends Type {
    get isSuccess() {
        return this.isSuccess;
    }
    get isFailure() {
        return this.isFailure;
    }
    get asSuccess() {
        return this.asSuccess;
    }
    get asFailure() {
        return this.asFailure;
    }
}
class MessageDispatchedData extends GearEventData {
    get messageId() {
        return this[0]['messageId'];
    }
    get outcome() {
        return this[0]['outcome'];
    }
}

class GearEvent extends GenericEvent {
    constructor(event) {
        super(event.registry, event.toU8a());
    }
}
class ProgramEvent extends GearEvent {
    get data() {
        return new ProgramData(this.get('data'));
    }
}
class InitSuccessEvent extends GearEvent {
    get data() {
        return new InitSuccessData(this.get('data'));
    }
}
class InitFailureEvent extends GearEvent {
    get data() {
        return new InitFailureData(this.get('data'));
    }
}
class LogEvent extends GearEvent {
    get data() {
        return new LogData(this.get('data'));
    }
}
class TransferEvent extends GearEvent {
    get data() {
        return new TransferData(this.get('data'));
    }
}
class InitMessageEnqueuedEvent extends GearEvent {
    get data() {
        return new InitMessageEnqueuedData(this.get('data'));
    }
}
class DispatchMessageEnqueuedEvent extends GearEvent {
    get data() {
        return new DispatchMessageEnqueuedData(this.get('data'));
    }
}
class DebugDataSnapshotEvent extends GearEvent {
    get data() {
        return new DebugData(this.get('data'));
    }
}
class MessageDispatchedEvent extends GearEvent {
    get data() {
        return new MessageDispatchedData(this.get('data'));
    }
}

class GearEvents {
    constructor(gearApi) {
        this.api = gearApi;
    }
    subscribeToLogEvents(callback) {
        return this.api.query.system.events((events) => {
            events
                .filter(({ event }) => this.api.events.gear.Log.is(event))
                .forEach(({ event }) => {
                setTimeout(() => {
                    callback(new LogEvent(event));
                }, 100);
            });
        });
    }
    subscribeToProgramEvents(callback) {
        return this.api.query.system.events((events) => {
            events
                .filter(({ event }) => this.api.events.gear.InitSuccess.is(event) || this.api.events.gear.InitFailure.is(event))
                .forEach(({ event }) => {
                setTimeout(() => {
                    callback(new ProgramEvent(event));
                }, 100);
            });
        });
    }
    subscribeToTransferEvents(callback) {
        return this.api.query.system.events((events) => {
            events
                .filter(({ event }) => this.api.events.balances.Transfer.is(event))
                .forEach(({ event }) => {
                callback(new TransferEvent(event));
            });
        });
    }
    subscribeToNewBlocks(callback) {
        return this.api.rpc.chain.subscribeNewHeads((header) => {
            callback(header);
        });
    }
    subscribeToBalanceChange(accountAddress, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            let { data: { free: previousFree }, } = (yield this.api.query.system.account(accountAddress));
            return this.api.query.system.account(accountAddress, ({ data: { free: currentFree } }) => {
                if (!currentFree.sub(previousFree).isZero()) {
                    callback(this.api.createType('Balance', currentFree));
                    previousFree = currentFree;
                }
            });
        });
    }
}

var importObj = (memory, showDebug, inputValue, timestamp) => ({
    env: {
        abortStackOverflow: () => {
            throw new Error('overflow');
        },
        table: new WebAssembly.Table({
            initial: 0,
            maximum: 0,
            element: 'anyfunc',
        }),
        tableBase: 0,
        memory: memory,
        memoryBase: 1024,
        STACKTOP: 0,
        STACK_MAX: memory.buffer.byteLength,
        alloc: (pages) => {
            return memory.grow(pages);
        },
        free: () => { },
        gr_block_height: () => { },
        gr_block_timestamp: () => timestamp,
        gr_exit: () => { },
        gr_gas_available: () => { },
        gr_program_id: () => { },
        gr_origin: () => { },
        gr_leave: () => { },
        gr_value_available: () => { },
        gr_wait: () => { },
        gr_wake: () => { },
        gr_exit_code: () => { },
        gr_msg_id: () => { },
        gr_read: (at, len, dest) => {
            new Uint8Array(memory.buffer).set(inputValue.slice(at, len), dest);
        },
        gr_reply: () => { },
        gr_reply_commit: () => { },
        gr_reply_push: () => { },
        gr_reply_to: () => { },
        gr_send: () => { },
        gr_send_wgas: () => { },
        gr_send_commit: () => { },
        gr_send_commit_wgas: () => { },
        gr_send_init: () => { },
        gr_send_push: () => { },
        gr_size: () => {
            return inputValue.byteLength;
        },
        gr_source: () => { },
        gr_value: () => { },
        gr_create_program_wgas: () => { },
        gr_debug: (msg) => {
            showDebug && console.log('GR_DEBUG: ', msg);
        },
    },
});

function readMetaValue(memory, func) {
    return ab2str(getExportValue(memory, func));
}
function getExportValue(memory, func) {
    if (!func) {
        return undefined;
    }
    const result_ptr = func();
    const pointer = new Uint32Array(memory.buffer.slice(result_ptr, result_ptr + 4))[0];
    const length = new Uint32Array(memory.buffer.slice(result_ptr + 4, result_ptr + 8))[0];
    const buf = memory.buffer.slice(pointer, pointer + length);
    return buf;
}
function ab2str(buf) {
    return String.fromCharCode.apply(null, new Uint8Array(buf));
}
function getInitialLength(pages) {
    return (parseInt(Object.keys(pages).reduce((prev, cur) => {
        if (parseInt(cur) > parseInt(prev)) {
            return cur;
        }
        return prev;
    })) + 1);
}
const PAGE_SIZE = 4096;

function getWasmMetadata(wasmBytes, showDebug = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const memory = new WebAssembly.Memory({ initial: 256 });
        const module = yield WebAssembly.instantiate(wasmBytes, importObj(memory, showDebug));
        const { exports } = module.instance;
        return exports
            ? {
                types: `0x${readMetaValue(memory, exports.meta_registry)}`,
                init_input: readMetaValue(memory, exports.meta_init_input),
                init_output: readMetaValue(memory, exports.meta_init_output),
                async_init_input: readMetaValue(memory, exports.meta_async_init_input),
                async_init_output: readMetaValue(memory, exports.meta_async_init_output),
                handle_input: readMetaValue(memory, exports.meta_handle_input),
                handle_output: readMetaValue(memory, exports.meta_handle_output),
                async_handle_input: readMetaValue(memory, exports.meta_async_handle_input),
                async_handle_output: readMetaValue(memory, exports.meta_async_handle_output),
                title: readMetaValue(memory, exports.meta_title),
                meta_state_input: readMetaValue(memory, exports.meta_state_input),
                meta_state_output: readMetaValue(memory, exports.meta_state_output),
            }
            : {};
    });
}

function readState(wasmBytes, pages, inputValue, blockTimestamp) {
    return __awaiter(this, void 0, void 0, function* () {
        const memory = new WebAssembly.Memory({ initial: getInitialLength(pages) });
        const module = yield WebAssembly.instantiate(wasmBytes, importObj(memory, false, inputValue, blockTimestamp));
        Object.keys(pages).forEach((pageNumber) => {
            const start = +pageNumber * PAGE_SIZE;
            const end = start + PAGE_SIZE;
            const page = pages[pageNumber];
            for (let i = start; i < end; i++) {
                new Uint8Array(memory.buffer)[i] = page[i % PAGE_SIZE];
            }
        });
        const { exports } = module.instance;
        return (exports === null || exports === void 0 ? void 0 : exports.meta_state) ? new Uint8Array(getExportValue(memory, exports.meta_state)) : null;
    });
}

class ReadStateError extends GearError {
    constructor(message) {
        super(message || `Can't read state.`);
        this.name = 'ReadStateError';
    }
}

const PREFIXES = {
    prog: Buffer.from('g::prog::').toString('hex'),
    pages: Buffer.from('g::pages::').toString('hex'),
};
const SEPARATOR = Buffer.from('::').toString('hex');
class GearStorage {
    constructor(api) {
        this.api = api;
        this.createType = new CreateType(api);
    }
    /**
     * Get program from chain
     * @param programId
     * @returns
     */
    gProg(programId) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = (yield this.api.rpc.state.getStorage(`0x${PREFIXES.prog}${programId.slice(2)}`));
            const program = this.api.createType('Program', storage.unwrap());
            return program.isActive ? program.asActive : program.asTerminated;
        });
    }
    /**
     * Get list of pages for program
     * @param programId
     * @param pagesList - list with pages numbers
     * @returns
     */
    gPages(programId, gProg) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = {};
            gProg.persistent_pages.forEach((value) => {
                keys[value.toNumber()] = `0x${PREFIXES.pages}${programId.slice(2)}${SEPARATOR}${this.api
                    .createType('Bytes', Array.from(this.api.createType('u32', value).toU8a()))
                    .toHex()
                    .slice(2)}`;
            });
            const pages = {};
            for (let key of Object.keys(keys)) {
                const storage = (yield this.api.rpc.state.getStorage(keys[key])).unwrap().toU8a();
                pages[key] = storage;
            }
            return pages;
        });
    }
    /**
     * Get codeHash of program on-chain
     * @param programId
     * @returns codeHash in hex format
     */
    getCodeHash(programId) {
        return __awaiter(this, void 0, void 0, function* () {
            const program = yield this.gProg(programId);
            return u8aToHex(program.code_hash);
        });
    }
}

class GearProgramState extends GearStorage {
    /**
     * Decode state to meta_state_output type
     * @param state - Uint8Array state representation
     * @param meta - Metadata
     * @returns decoded state
     */
    decodeState(state, meta) {
        if (!state) {
            throw new ReadStateError(`Unable to read state. meta_state function is not specified in metadata`);
        }
        const bytes = this.api.createType('Bytes', Array.from(state));
        const decoded = this.createType.create(meta.meta_state_output, bytes, meta);
        return decoded;
    }
    /**
     * Encode input parameters to read meta state
     * @param meta - Metadata
     * @param inputValue - input parameters
     * @returns ArrayBuffer with encoded data
     */
    encodeInput(meta, inputValue) {
        const encoded = this.createType.create(meta.meta_state_input, inputValue, meta);
        return encoded.toU8a();
    }
    /**
     * Read state of particular program
     * @param programId
     * @param metaWasm - file with metadata
     * @returns decoded state
     */
    read(programId, metaWasm, inputValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const program = yield this.gProg(programId);
            if (!program) {
                throw new ReadStateError('Program is terminated');
            }
            const pages = yield this.gPages(programId, program);
            const block = yield this.api.blocks.getFinalizedHead();
            const blockTimestamp = yield this.api.blocks.getBlockTimestamp(block.toHex());
            if (!pages) {
                throw new ReadStateError(`Unable to read state. Unable to recieve program pages from chain`);
            }
            const metadata = yield getWasmMetadata(metaWasm);
            if (!metadata.meta_state_output) {
                throw new ReadStateError(`Unable to read state. meta_state_output type is not specified in metadata`);
            }
            if (metadata.meta_state_input && inputValue === undefined) {
                throw new ReadStateError(`Unable to read state. inputValue not specified`);
            }
            const encodedInput = inputValue === undefined ? undefined : this.encodeInput(metadata, inputValue);
            const state = yield readState(metaWasm, pages, encodedInput, blockTimestamp);
            return this.decodeState(state, metadata);
        });
    }
}

class GearMessageReply extends GearTransaction {
    /**
     * Sends reply message
     * @param message Message parameters
     * @param meta Metadata
     * @param messageType MessageType
     * @returns Submitted result
     * @example
     * ```javascript
     * const api = await GearApi.create()
     * const messageId = '0xd7540ae9da85e33b47276e2cb4efc2f0b58fef1227834f21ddc8c7cb551cced6'
     * api.reply.submit({
     *  replyToId: messageId,
     *  payload: 'Reply message',
     *  gasLimit: 20_000_000
     * }, undefiend, 'String')
     * api.reply.signAndSend(account, (events) => {
     *  events.forEach(({event}) => console.log(event.toHuman()))
     * })
     * ```
     */
    submit(message, meta, messageType) {
        let payload = createPayload(this.createType, messageType || (meta === null || meta === void 0 ? void 0 : meta.async_handle_input) || (meta === null || meta === void 0 ? void 0 : meta.async_init_input), message.payload, meta);
        try {
            this.submitted = this.api.tx.gear.sendReply(message.replyToId, payload, message.gasLimit, message.value);
            return this.submitted;
        }
        catch (error) {
            throw new SendReplyError();
        }
    }
}

var rpc = {
	gear: {
		getInitGasSpent: {
			description: "Get GasSpent for Init message",
			params: [
				{
					name: "source",
					type: "H256"
				},
				{
					name: "code",
					type: "Vec<u8>"
				},
				{
					name: "payload",
					type: "Vec<u8>"
				},
				{
					name: "value",
					type: "u128"
				}
			],
			type: "u64"
		},
		getHandleGasSpent: {
			description: "Get GasSpent for Handle message",
			params: [
				{
					name: "source",
					type: "H256"
				},
				{
					name: "dest",
					type: "H256"
				},
				{
					name: "payload",
					type: "Vec<u8>"
				},
				{
					name: "value",
					type: "u128"
				}
			],
			type: "u64"
		},
		getReplyGasSpent: {
			description: "Get GasSpent for Handle message",
			params: [
				{
					name: "source",
					type: "H256"
				},
				{
					name: "message_id",
					type: "H256"
				},
				{
					name: "exit_code",
					type: "i32"
				},
				{
					name: "payload",
					type: "Vec<u8>"
				},
				{
					name: "value",
					type: "u128"
				}
			],
			type: "u64"
		}
	}
};
var rpc$1 = {
	rpc: rpc
};

var rpc$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    rpc: rpc,
    'default': rpc$1
});

var types$2 = {
	ProgramId: "[u8; 32]",
	Program: {
		_enum: {
			Active: "ActiveProgram",
			Terminated: "Null"
		}
	},
	WasmPageNumber: "u32",
	PageNumber: "u32",
	ActiveProgram: {
		static_pages: "WasmPageNumber",
		persistent_pages: "BTreeSet<PageNumber>",
		code_hash: "H256",
		state: "ProgramState"
	},
	ProgramState: {
		_enum: {
			Uninitialized: {
				message_id: "H256"
			},
			Initialized: "Null"
		}
	},
	ExecutionResult: {
		_enum: {
			Success: "Null",
			Failure: "Vec<u8>"
		}
	}
};
var typesProgram = {
	types: types$2
};

var typesProgram$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    types: types$2,
    'default': typesProgram
});

var types$1 = {
	MessageId: "[u8; 32]",
	ExitCode: "i32",
	Payload: "Vec<u8>",
	Message: {
		id: "H256",
		source: "H256",
		destination: "H256",
		payload: "Payload",
		gas_limit: "u64",
		value: "u128",
		reply: "Option<(H256, ExitCode)>"
	},
	PayloadStore: {
		outgoing: "BTreeMap<u64, Option<Payload>>",
		new_programs: "Vec<ProgramId>",
		reply: "Option<Payload>",
		awaken: "Vec<MessageId>",
		reply_was_sent: "bool"
	},
	Dispatch: {
		kind: "DispatchKind",
		message: "Message",
		payload_store: "Option<PayloadStore>"
	},
	DispatchKind: {
		_enum: [
			"Init",
			"Handle",
			"HandleReply"
		]
	},
	QueuedMessage: {
		id: "H256",
		source: "H256",
		destination: "H256",
		payload: "Vec<u8>",
		value: "u128",
		reply: "Option<(H256, i32)>"
	},
	QueuedDispatch: {
		kind: "DispatchKind",
		message: "QueuedMessage",
		payload_store: "Option<PayloadStore>"
	},
	Reason: {
		_enum: {
			"Error": "Null",
			ValueTransfer: "Null",
			Dispatch: "Vec<u8>"
		}
	},
	DispatchOutcome: {
		message_id: "H256",
		outcome: "ExecutionResult"
	},
	MessageInfo: {
		message_id: "H256",
		program_id: "H256",
		origin: "H256"
	}
};
var typesMessage = {
	types: types$1
};

var typesMessage$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    types: types$1,
    'default': typesMessage
});

var types = {
	ProgramDetails: {
		id: "H256",
		static_pages: "u32",
		persistent_pages: "BTreeMap<u32, Vec<u8>>",
		code_hash: "H256",
		nonce: "u64"
	},
	DebugData: {
		dispatch_queue: "Vec<QueuedDispatch>",
		programs: "Vec<ProgramDetails>"
	}
};
var typesDebug = {
	types: types
};

var typesDebug$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    types: types,
    'default': typesDebug
});

const gearRpc = transformTypes(rpc$2).rpc;
const gearTypes = Object.assign(Object.assign(Object.assign({}, transformTypes(typesProgram$1).types), transformTypes(typesMessage$1).types), transformTypes(typesDebug$1).types);

class GetBlockError extends GearError {
    constructor(message, hash) {
        super();
        this.name = 'GetBlockError';
        const splittedMessage = message.split(':');
        if (isU8a(hash)) {
            hash = u8aToString(hash);
        }
        const errorCode = splittedMessage.length > 0 ? parseInt(splittedMessage[0]) : NaN;
        switch (errorCode) {
            case -32603:
                this.message = `State already discarded for block ${hash}`;
                break;
            default:
                this.message = 'Unknow error occurred';
                break;
        }
    }
}

class GearBlock {
    constructor(api) {
        this.api = api;
    }
    /**
     * Get data of particular block by blockNumber or blockHash
     * @param hashOrNumber
     * @returns
     */
    get(hashOrNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = isU8a(hashOrNumber) || isHex(hashOrNumber) ? hashOrNumber : yield this.getBlockHash(+hashOrNumber);
            try {
                return yield this.api.rpc.chain.getBlock(hash);
            }
            catch (error) {
                throw new GetBlockError(error.message, hash);
            }
        });
    }
    /**
     * Get blockHash by number
     * @param number number of block
     * @returns blockHash
     */
    getBlockHash(number) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.rpc.chain.getBlockHash(number);
        });
    }
    /**
     * Get block number
     * @param hash
     * @returns Compact<BlockNumber>
     */
    getBlockNumber(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = yield this.get(hash);
            return block.block.header.number;
        });
    }
    /**
     * Get timestamp of block
     * @param hashOrNumber hash or number of particular block
     * @returns
     */
    getBlockTimestamp(hashOrNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = yield this.get(hashOrNumber);
            const tsAsU8a = block.block.extrinsics.find((value) => value.method.method === 'set' && value.method.section === 'timestamp').data;
            const ts = CreateType.create('Compact<u64>', tsAsU8a);
            return ts;
        });
    }
    /**
     * Get all extrinsic of particular block
     * @param blockHash hash of particular block
     * @returns Vec of extrinsics
     */
    getExtrinsics(blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.get(blockHash)).block.extrinsics;
        });
    }
    /**
     * Get all events of particular block
     * @param blockHash hash of particular block
     * @returns Vec of events
     */
    getEvents(blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const apiAt = yield this.api.at(blockHash);
            return apiAt.query.system.events();
        });
    }
    /**
     * Get hash of last finalized block
     * @returns Hash of finalized head
     */
    getFinalizedHead() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api.rpc.chain.getFinalizedHead();
        });
    }
}

class GearMailbox {
    constructor(gearApi) {
        this.api = gearApi;
        this.claimValue = gearApi.claimValueFromMailbox;
    }
    /**
     * Read mailbox
     * @param accountId
     * @returns
     * @example
     * ```javascript
     * const api = await GearApi.create();
     * const mailbox = await api.mailbox.read('5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY');
     * console.log(mailbox);
     * ```
     */
    read(accountId, messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (messageId) {
                const mailbox = yield this.api.query.gear['mailbox'](accountId, messageId);
                return mailbox.toHuman();
            }
            else {
                const keys = yield this.api.query.gear['mailbox'].keys(accountId);
                if (keys.length === 0) {
                    return [];
                }
                const keyPrefixes = this.api.query.gear['mailbox'].keyPrefix(accountId);
                const keysPaged = yield this.api.rpc.state.getKeysPaged(keyPrefixes, 1000, keyPrefixes);
                const mailbox = (yield this.api.rpc.state.queryStorageAt(keysPaged));
                return mailbox.map((option, index) => {
                    return [
                        keys[index].toHuman(),
                        this.api
                            .createType('GearCoreMessageStoredStoredMessage', option.unwrap())
                            .toHuman(),
                    ];
                });
            }
        });
    }
}

class ClaimValueError extends GearError {
    constructor(message) {
        super(message || `Unable to claim value from mailbox. Params are invalid`);
        this.name = 'ClaimValueError';
    }
}

/**
 * Claim value from mailbox
 */
class GearClaimValue extends GearTransaction {
    /**
     * Submit `claimValueFromMailbox` extrinsic
     * @param messageId MessageId with value to be claimed
     */
    submit(messageId) {
        try {
            this.submitted = this.api.tx.gear.claimValueFromMailbox(messageId);
            return this.submitted;
        }
        catch (error) {
            throw new ClaimValueError();
        }
    }
}

class GearCode extends GearTransaction {
    /**
     * Submit code without initialization
     * @param code
     * @returns Code hash
     */
    submit(code) {
        const codeBytes = this.createType.create('bytes', Array.from(code));
        this.submitted = this.api.tx.gear.submitCode(codeBytes);
        const codeHash = generateCodeHash(code);
        return codeHash;
    }
}

class GearApi extends ApiPromise {
    constructor(options = {}) {
        const { types, providerAddress } = options, restOptions = __rest(options, ["types", "providerAddress"]);
        const provider = (restOptions === null || restOptions === void 0 ? void 0 : restOptions.provider) || new WsProvider(providerAddress !== null && providerAddress !== void 0 ? providerAddress : 'ws://127.0.0.1:9944');
        const defaultTypes = types ? Object.assign(Object.assign({}, types), gearTypes) : gearTypes;
        super(Object.assign({ provider, derives: {}, types: Object.assign({}, defaultTypes), rpc: Object.assign({}, gearRpc) }, restOptions));
        this.isReady.then(() => {
            this.program = new GearProgram(this);
            this.message = new GearMessage(this);
            this.balance = new GearBalance(this);
            this.reply = new GearMessageReply(this);
            this.gearEvents = new GearEvents(this);
            this.defaultTypes = defaultTypes;
            this.programState = new GearProgramState(this);
            this.blocks = new GearBlock(this);
            this.storage = new GearStorage(this);
            this.claimValueFromMailbox = new GearClaimValue(this);
            this.mailbox = new GearMailbox(this);
            this.code = new GearCode(this);
        });
    }
    static create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = new GearApi(options);
            yield api.isReady;
            return api;
        });
    }
    totalIssuance() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.query.balances.totalIssuance()).toHuman();
        });
    }
    chain() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.rpc.system.chain()).toHuman();
        });
    }
    nodeName() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.rpc.system.name()).toHuman();
        });
    }
    nodeVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.rpc.system.version()).toHuman();
        });
    }
    /**
     * Method provides opportunity to get informations about error occurs in ExtrinsicFailed event
     * @param event
     * @returns
     */
    getExtrinsicFailedError(event) {
        const error = event.data[0];
        const { isModule, asModule } = error;
        return isModule ? this.registry.findMetaError(asModule) : null;
    }
}

class DebugMode extends GearTransaction {
    enable() {
        this.enabled = this.api.tx.sudo.sudo(this.api.tx.gearDebug.enableDebugMode(true));
    }
    disable() {
        this.enabled = this.api.tx.sudo.sudo(this.api.tx.gearDebug.enableDebugMode(false));
    }
    snapshots(callback) {
        return this.api.query.system.events((events) => {
            events
                .filter(({ event }) => this.api.events.gearDebug.DebugDataSnapshot.is(event))
                .forEach(({ event }) => callback(new DebugDataSnapshotEvent(event)));
        });
    }
}

const REGULAR_EXP = {
    endWord: /\b\w+\b/g,
    angleBracket: /<.+>/,
    roundBracket: /^\(.+\)$/,
    squareBracket: /^\[.+\]$/,
};
const STD_TYPES = {
    Result: (ok, err) => {
        return {
            _enum_Result: {
                ok,
                err,
            },
        };
    },
    Option: (some) => {
        return {
            _enum_Option: some,
        };
    },
    Vec: (type) => {
        return [type];
    },
    VecDeque: (type) => {
        return [type];
    },
    BTreeMap: (key, value) => {
        return {
            [key]: value,
        };
    },
};
/**
 * @deprecated use `decodeHexTypes`
 */
function parseHexTypes(hexTypes) {
    let { typesFromTypeDef, namespaces } = getTypesFromTypeDef(hexToU8a(hexTypes));
    const result = {};
    namespaces.forEach((value, key) => {
        const replaced = replaceNamespaces(typesFromTypeDef[value], namespaces);
        result[key] = isJSON(replaced) ? JSON.parse(replaced) : replaced;
    });
    return result;
}
/**
 * @deprecated will be removed in 0.16.0 version
 */
function getTypeStructure(typeName, types) {
    if (!typeName) {
        return undefined;
    }
    // check tuples
    let match = typeName.match(REGULAR_EXP.roundBracket);
    if (match) {
        const entryType = match[0].slice(1, match[0].length - 1);
        const splitted = splitByCommas(entryType);
        return splitted.map((value) => getTypeStructure(value, types));
    }
    // check arrays
    match = typeName.match(REGULAR_EXP.squareBracket);
    if (match) {
        const splitted = typeName.slice(1, typeName.length - 1).split(';');
        return new Array(+splitted[1]).fill(getTypeStructure(splitted[0], types));
    }
    // check generic
    match = typeName.match(REGULAR_EXP.angleBracket);
    if (match) {
        const stdType = typeName.slice(0, match.index);
        if (stdType in STD_TYPES) {
            const entryType = match[0].slice(1, match[0].length - 1);
            const splitted = splitByCommas(entryType);
            return STD_TYPES[stdType](getTypeStructure(splitted[0], types), getTypeStructure(splitted[1], types));
        }
        else {
            return getTypeStructure(stdType, types);
        }
    }
    const type = isJSON(typeName) ? toJSON(JSON.stringify(types[typeName])) : types[typeName];
    // check custom types
    if (!type) {
        return typeName;
    }
    if (typeof type === 'object') {
        const result = {};
        Object.keys(type).forEach((key) => {
            if (key === '_enum') {
                result['_enum'] = type[key];
                Object.keys(result['_enum']).forEach((subKey) => {
                    result['_enum'][subKey] = getTypeStructure(result['_enum'][subKey], types);
                });
            }
            else {
                result[key] =
                    type[key] in types || type[key].match(REGULAR_EXP.angleBracket)
                        ? getTypeStructure(type[key], types)
                        : type[key];
            }
        });
        return result;
    }
    else {
        return type;
    }
}

export { CreateType, DebugData, DebugDataSnapshotEvent, DebugMode, DispatchMessageEnqueuedData, DispatchMessageEnqueuedEvent, ExecutionResult, GearApi, GearBalance, GearBlock, GearClaimValue, GearEvent, GearEventData, GearEvents, GearGasSpent, GearKeyring, GearMailbox, GearMessage, GearMessageReply, GearProgram, GearProgramState, GearStorage, GearTransaction, InitFailureData, InitFailureEvent, InitMessageEnqueuedData, InitMessageEnqueuedEvent, InitSuccessData, InitSuccessEvent, LogData, LogEvent, MessageDispatchedData, MessageDispatchedEvent, MessageInfoData, ProgramData, ProgramEvent, TransferData, TransferEvent, checkTypeAndPayload, createPayload, createPayloadTypeStructure, decodeHexTypes, enumTypes, generateCodeHash, generateProgramId, getTypeStructure, getTypesFromTypeDef, getWasmMetadata, isJSON, parseHexTypes, readState, replaceNamespaces, setNamespaces, splitByCommas, toCamelCase, toJSON, transformTypes, typeIsString };
//# sourceMappingURL=index.mjs.map
