"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateType = void 0;
const json_1 = require("../utils/json");
const util_1 = require("@polkadot/util");
const types_1 = require("@polkadot/types");
const utils_1 = require("./utils");
class CreateType {
    constructor(gearApi) {
        this.registry = (gearApi === null || gearApi === void 0 ? void 0 : gearApi.registry) || new types_1.TypeRegistry();
        this.namespaces = undefined;
    }
    createRegistry(types) {
        if (!types) {
            return null;
        }
        if ((0, util_1.isHex)(types) || (0, util_1.isU8a)(types)) {
            const { typesFromTypeDef, namespaces } = (0, utils_1.getTypesFromTypeDef)(types, this.registry);
            types = typesFromTypeDef;
            this.namespaces = namespaces;
        }
        this.registerTypes(types);
        return this.namespaces;
    }
    /**
     * Register custom types in case of use custom types without
     * @param types
     * @example
     * ```javascript
     * const types = {
     *    CustomStruct: {
     *      fieldA: 'String',
     *      fieldB: 'u8'
     *    },
     *    CustomEnum: {
     *      _enum: {
     *        optionA: 'Option<CustomStruct>',
     *        optionB: 'BTreeSet<i32>'
     *      }
     *    }
     * };
     * const createType = new CreateType();
     * createType.registerTypes(types);
     * createType.create('CustomStruct', { fieldA: 'Hello', fieldB: 255 });
     * ```
     */
    registerTypes(types) {
        this.registry.setKnownTypes({ types: Object.assign({}, types) });
        this.registry.register(Object.assign({}, types));
    }
    /**
     *
     * @param type `TypeName` to encode or decode payload
     * @param payload `Payload` that have to be encoded or decoded
     * @param meta `Metadata` if type isn't standart rust Type
     * @returns Codec
     * @example
     * ```javascript
     * const createType = new CreateType();
     * const encoded = createType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     *
     * const decoded = createType.create('String', '0x48656c6c6f2c20576f726c6421');
     * console.log(decoded.toHuman()); // "Hello, World!"
     *
     * // create type with metadata
     * const metadata = fs.readFileSync('path/to/file/with/metadata/*.meta.wasm);
     * const encoded = create(metadata.handle_input, somePayload, metadata);
     * console.log(encoded.toHex());
     * ```
     */
    create(type, payload, meta) {
        type = (0, utils_1.checkTypeAndPayload)(type, payload);
        const namespaces = (meta === null || meta === void 0 ? void 0 : meta.types) ? this.createRegistry(meta.types) : this.createRegistry();
        return this.createType(namespaces ? (0, utils_1.setNamespaces)(type, namespaces) : type, (0, json_1.isJSON)(payload) ? (0, json_1.toJSON)(payload) : payload);
    }
    /**
     *
     * @param type `TypeName` to encode or decode payload
     * @param payload `Payload` that have to be encoded or decoded
     * @param meta `Metadata` if type isn't standart rust Type
     * @returns Codec
     * @example
     * ```javascript
     * const encoded = CreateType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     * ```
     */
    static create(type, payload, meta) {
        const createType = new CreateType();
        return createType.create(type, payload, meta);
    }
    createType(type, data) {
        if ((0, utils_1.typeIsString)(type)) {
            return this.registry.createType('String', data);
        }
        else if (type.toLowerCase() === 'bytes') {
            if (data instanceof Uint8Array) {
                return this.registry.createType('Bytes', Array.from(data));
            }
            else if (data instanceof types_1.Bytes) {
                return data;
            }
            return this.registry.createType('Bytes', data);
        }
        else {
            return this.registry.createType(type, data);
        }
    }
    /**
     * @deprecated use `CreateType.create()`
     */
    static encode(type, payload, meta) {
        const createType = new CreateType();
        return createType.create(type, payload, meta);
    }
    /**
     * @deprecated use `CreateType.create()`
     */
    static decode(type, payload, meta) {
        const createType = new CreateType();
        return createType.create(type, payload, meta);
    }
}
exports.CreateType = CreateType;
