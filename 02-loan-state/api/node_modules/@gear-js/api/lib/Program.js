"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GearProgram = void 0;
const errors_1 = require("./errors");
const util_crypto_1 = require("@polkadot/util-crypto");
const Transaction_1 = require("./Transaction");
const utils_1 = require("./utils");
const GasSpent_1 = require("./GasSpent");
class GearProgram extends Transaction_1.GearTransaction {
    constructor(gearApi) {
        super(gearApi);
        this.gasSpent = new GasSpent_1.GearGasSpent(gearApi);
    }
    /**
     * @param program Upload program data
     * @param meta Metadata
     * @returns ProgramId
     * @example
     * ```javascript
     * const code = fs.readFileSync('path/to/program.opt.wasm');
     * const meta = await getWasmMetadata(fs.readFileSync('path/to/program.meta.wasm'));
     * const api = await GearApi.create();
     * const { programId, salt, submitted } = api.program.submit({
     *   code,
     *   initPayload: {field: 'someValue'},
     *   gasLimit: 20_000_000,
     * }, meta)
     * api.program.signAndSend(account, (events) => {
     *   events.forEach(({event}) => console.log(event.toHuman()))
     * })
     * ```
     */
    submit(program, meta, messageType) {
        const salt = program.salt || (0, util_crypto_1.randomAsHex)(20);
        const code = this.createType.create('bytes', Array.from(program.code));
        let payload = (0, utils_1.createPayload)(this.createType, messageType || (meta === null || meta === void 0 ? void 0 : meta.init_input), program.initPayload, meta);
        try {
            this.submitted = this.api.tx.gear.submitProgram(code, salt, payload, program.gasLimit, program.value || 0);
            const programId = (0, utils_1.generateProgramId)(code, salt);
            return { programId, salt, submitted: this.submitted };
        }
        catch (error) {
            throw new errors_1.SubmitProgramError();
        }
    }
    /**
     * Get ids of all uploaded programs
     * @returns
     */
    allUploadedPrograms() {
        return __awaiter(this, void 0, void 0, function* () {
            let programs = (yield this.api.rpc.state.getKeys('g::prog::')).map((prog) => {
                return `0x${prog.toHex().slice(Buffer.from('g::prog::').toString('hex').length + 2)}`;
            });
            return programs;
        });
    }
}
exports.GearProgram = GearProgram;
