"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateProgramId = exports.generateCodeHash = exports.createPayload = void 0;
const util_1 = require("@polkadot/util");
const CreateType_1 = require("../create-type/CreateType");
const util_crypto_1 = require("@polkadot/util-crypto");
function createPayload(createType, type, data, meta) {
    if (data === undefined) {
        return '0x00';
    }
    if ((0, util_1.isHex)(data)) {
        return data;
    }
    else if ((0, util_1.isU8a)(data)) {
        return (0, util_1.u8aToHex)(data);
    }
    let payload = data;
    if (meta && type) {
        const encoded = createType.create(type, data, meta);
        payload = (0, util_1.isHex)(encoded) ? encoded : encoded.toHex();
    }
    else if (type) {
        try {
            const encoded = createType.create(type, data);
            payload = (0, util_1.isHex)(encoded) ? encoded : encoded.toHex();
        }
        catch (error) {
            console.error(error.message);
        }
    }
    return payload;
}
exports.createPayload = createPayload;
function generateCodeHash(code) {
    return (0, util_crypto_1.blake2AsHex)(code, 256);
}
exports.generateCodeHash = generateCodeHash;
function generateProgramId(code, salt) {
    const codeHashU8a = (0, util_crypto_1.blake2AsU8a)(code, 256);
    const saltU8a = CreateType_1.CreateType.create('Vec<u8>', salt).toU8a().slice(1);
    const id = new Uint8Array(codeHashU8a.byteLength + saltU8a.byteLength);
    id.set(codeHashU8a);
    id.set(saltU8a, codeHashU8a.byteLength);
    return (0, util_crypto_1.blake2AsHex)(id, 256);
}
exports.generateProgramId = generateProgramId;
