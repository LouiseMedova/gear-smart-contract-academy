"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeStructure = exports.parseHexTypes = void 0;
const string_1 = require("./utils/string");
const json_1 = require("./utils/json");
const util_1 = require("@polkadot/util");
const create_type_1 = require("./create-type");
const REGULAR_EXP = {
    endWord: /\b\w+\b/g,
    angleBracket: /<.+>/,
    roundBracket: /^\(.+\)$/,
    squareBracket: /^\[.+\]$/,
};
const STD_TYPES = {
    Result: (ok, err) => {
        return {
            _enum_Result: {
                ok,
                err,
            },
        };
    },
    Option: (some) => {
        return {
            _enum_Option: some,
        };
    },
    Vec: (type) => {
        return [type];
    },
    VecDeque: (type) => {
        return [type];
    },
    BTreeMap: (key, value) => {
        return {
            [key]: value,
        };
    },
};
/**
 * @deprecated use `decodeHexTypes`
 */
function parseHexTypes(hexTypes) {
    let { typesFromTypeDef, namespaces } = (0, create_type_1.getTypesFromTypeDef)((0, util_1.hexToU8a)(hexTypes));
    const result = {};
    namespaces.forEach((value, key) => {
        const replaced = (0, create_type_1.replaceNamespaces)(typesFromTypeDef[value], namespaces);
        result[key] = (0, json_1.isJSON)(replaced) ? JSON.parse(replaced) : replaced;
    });
    return result;
}
exports.parseHexTypes = parseHexTypes;
/**
 * @deprecated will be removed in 0.16.0 version
 */
function getTypeStructure(typeName, types) {
    if (!typeName) {
        return undefined;
    }
    // check tuples
    let match = typeName.match(REGULAR_EXP.roundBracket);
    if (match) {
        const entryType = match[0].slice(1, match[0].length - 1);
        const splitted = (0, string_1.splitByCommas)(entryType);
        return splitted.map((value) => getTypeStructure(value, types));
    }
    // check arrays
    match = typeName.match(REGULAR_EXP.squareBracket);
    if (match) {
        const splitted = typeName.slice(1, typeName.length - 1).split(';');
        return new Array(+splitted[1]).fill(getTypeStructure(splitted[0], types));
    }
    // check generic
    match = typeName.match(REGULAR_EXP.angleBracket);
    if (match) {
        const stdType = typeName.slice(0, match.index);
        if (stdType in STD_TYPES) {
            const entryType = match[0].slice(1, match[0].length - 1);
            const splitted = (0, string_1.splitByCommas)(entryType);
            return STD_TYPES[stdType](getTypeStructure(splitted[0], types), getTypeStructure(splitted[1], types));
        }
        else {
            return getTypeStructure(stdType, types);
        }
    }
    const type = (0, json_1.isJSON)(typeName) ? (0, json_1.toJSON)(JSON.stringify(types[typeName])) : types[typeName];
    // check custom types
    if (!type) {
        return typeName;
    }
    if (typeof type === 'object') {
        const result = {};
        Object.keys(type).forEach((key) => {
            if (key === '_enum') {
                result['_enum'] = type[key];
                Object.keys(result['_enum']).forEach((subKey) => {
                    result['_enum'][subKey] = getTypeStructure(result['_enum'][subKey], types);
                });
            }
            else {
                result[key] =
                    type[key] in types || type[key].match(REGULAR_EXP.angleBracket)
                        ? getTypeStructure(type[key], types)
                        : type[key];
            }
        });
        return result;
    }
    else {
        return type;
    }
}
exports.getTypeStructure = getTypeStructure;
